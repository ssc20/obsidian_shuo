#therapy 
- Quick question
	- Jawad therapy, social group Palestine
		- 
- ego, math
	- values
	- someone's 
- expert might be different
	- what qualifies an expert
	- shame
		- someone of less expertise is giving me advice


#cs50/week2 

#scope
scope: characteristic of a variable that defines
- from which functions that this variable can be accessed

- local variables can only be accesssed within teh functions in which they are creatd
- global variables can be accessed by any function in the program

- so far in the course, you've almost always been working only with local variables
```c
int main(void)
{
	int result = triple(5);
}

int triple(int x)
{
	return x * 3;*
}
```

- here, x is local to the function `triple()`. 
- no other function can refer to that variable, not even `main()`. `result` is **local** to `main()`

- global variables exist too
- if a variable is declared outside of all functions, **any** function may refer to it

```c
#include <stdio.h>

float flobal = 0.5050;

int main(void)
{
	triple();
	printf(%f\n", global);
}

void triple(void)
{
	global *= 3;
}
```

- if i go through the program
	- main calls triple
	- triple multiples global by 3
		- 1.5 something (return)
		- main prints out the value of global
		- it will print out global times 3, 1.51
	- have to be careful when working with global because of its flexibility (dangerous consequences)
- why does this distinction matter
	- local variables are **passed by value** in function calls
	- the callee (function receiving the variable passed in as input) doesn't actually receive the variable itself
	- again:
		- when a variable is passed by value, the **callee** receives a *copy* of the passed variable, not the variable itself
		- this means that the variable in the **caller** is unchanged unless overwritten.
	- the variable in the caller is unchanged unless you override it

```c
int main(void)
{
	int foo = 4;
	triple(foo);
}

int triple(int x)
{
	return x *= 3;
}

```

- in this code, foo is not changed at all
	- int foo = 4
	- call triple of foo
	- you can see that there's no effect

compared to

```c

int main(void)
{
	int foo = 4;
	foo = triple(foo);
}

int triple(int x)
{
	return x *= 3;
}

```

- this here, we are overriding/reassigning what `foo` is equal to
	- you would see ``printf("%i\n", foo)`` to equal 12
- things can get insidious if the same variable name appears in multiple functions
	- which is perfectly okay as long as the variables exist in different scopes

do you know what gets printed out at the end of this particular program?

```c
int increment(int x);

int main(void)
{
	int x = 1;
	int y;
	y = increment(x);
	printf("x is %i, y is %i\n", x, y);
}

int increment(int x)
{
	x++;
	return x;
}
```

- (do i get `x is 1, y is 2`?)

#debugging #debug50


- guess program
- guess wrong, infinite output flood


```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
	int number = 5;

	int guess = get_int("What's your guess? ");

	while (guess != number)
	{
		printf("Wrong guess!");
	}
	
	printf("You're correct!");
}
```
- go to left side and see the red circles pop up to turn it bright red
- use debug50 to step through the code
- code opened up in `debug50`
	- my `number `variable is set 0
	- my `guess` is 32764
- `number` set to 5 as intended
- `guess` becomes 3
- if my `guess` is wrong and `number` not equal
	- shouldn't I just get Wrong guess?
- go through code with "step over"
- line in yellow highlight goes back to lkne 10
	- it goes through again and prints "wrong guess"
- i should've used an if statement that checks **once** rather than indefinitely with *while*
- however, now it's returning also `You're correct`


```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
	int number = 5;

	int guess = get_int("What's your guess? ");

	if (guess != number)
	{
		printf("Wrong guess!");
	}
	else
	{
		printf("You're correct!");
	}
}


```

#debugging

- secret program
	- type in the right password, you should see "come right in"
- the password is "please"
- but we don't see anything...

```c
#include <cs50.h>

bool check_phrase(string);

int main(void)
{
	string phrase = get_string("What's the secret phrase? ");

	bool correct = check_phrase(phrase);

	if (correct == true)

}

bool check_phrase(string phrase)
{
	string password = "Please";
	// 0 means true
	if (strcmp(phrase, password == 0)
	{
		return true;
	}

	return false;
}
}

```

- set a break point, or p lace t opause in our code
- find a pale red circle, click it, set it (carter sets it to line 9)
- i can run `debug 50 secret`
	- code should boot up and pause right at that moment
	- need to step over to actually run that part of the program
- `phrase` becomes 0xd136b0 "Please"
	- `correct` stays false
	- so the print does not come in
- haven't seen what's wrong in my code..
- let's step into a function
	- run it again, let's dive into the function
	- stepping into this, i can see that `phrase == password` is true
	- HOWEVER you can't compare 2 strings with equal signs
	- you need `strcmp`, which i've added in.
- make secret again
	- run secret, type in password of `please`
	- now it says `come on in`
	- mission success!


#CS50/arrays 

- arrays are a fundamental **data structure**, and they are extremely useful
- we use arrays to hold values of the same type at contiguous memory locations
- one way to analogize the notion of array is to think of your local post office, which usually has a large bank of post office boxes.

- ==Arrays==
	- an **array** is a block of contiguous space in memory
	- which has been partitioned into small, identically-sized blocks of space called **elements**
	- each of which can store a certain amount of **data**
	- all of the same data type such as **int** or **char**
	- and which can be accessed directly by an **index**
- ==Post office boxes==
	- a **mail bank** is a large space on the wall of the post office
	- which has been partioned into small, identically-sized blocks of space called **post office boxes**
	- each of which can hold a certain amount of **mail**
	- all of a similar type such as **letters** or **small packages**
	- and which can be accessed directly by a **mailbox number**

- in C, the elements of an array are indexed starting from 0
	- this is one of the major reasons we count from zero
- if an array consists of *n* elements, the first element is located at index 0
	- the last element is located at `(n-1`
- C is very lenient.
	- it will not prevent you from going "out of bounds" of your array; be careful!
		- might get a `segmentation fault`
- Array declarations
- #array/declaration
- `type name[size];`
	- the `type` is what kind of variable each element of the array will be
	- the `name` is what you want to call your array
	- the `size` is how many elements you would like your array to contain.
		- e.g. how many integers do you want?
	- `int student_grades[40];`
		- declares array called `Student_grades` consisting of `40` integers
	-  `double menu_prices[8]`
		- declaers array with room for 8 doubles
- if you think of a single element of an array of type `data-type` the same as you would any other variable of type `data-type` (which ,effectively, it is) then all the familiar operations make sense.
```c
bool truthtable[10];

truthtable[2] = false;
if(truthtable[7] == true;)
{
	printf("TRUE!\n");
}
truthtable[10] = true;
```
- `truthtable[2]` is the 3rd entry (remember counting from 0)
- `truthtable[7] == true`
	- this is the 8th, remember!
- `truthtable[10]`, this is** higher** than the highest index, which is the** 9th** number
	- again think n-1
	- this is legal, but if something exists in memory where 10 is,
		- might suffer **segmentation fault**
- when declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values
- #cs50/neat
```c
// instantiation syntax
bool truthtable[3] = { false, true, true };

// OR
bool truthtable[] = { false, true, true };

// individual element syntax
bool truthtable[3];
truthtable[0] = false;
truthtable[1] = true;
truthtable[2] = true;
```
- very good at home exercise to practice `loops` with arrays
- notice above that in `instantiation syntax` that you don't need to declare how many elements there are
- arrays can consist of more than a singel dimension
	- you can have as many size specifiers as you wish.
`bool battleship[10][10];`
- you can choose to think of this as either a 10x10 grid of cells
	- in memory though, it's really just a 100-element one-dimensional array
	- multi-dimensional arrays are great **abstractions** to help visualize game boards or other complex representations.
		- instead of having to think of tic tac toe or battleship as a single-line (thinking about this concept in technicalities)
- while we can treat individual elements of arrays as variables ,we cannot treat entire arrays themselves as variables
- we cannot for instance assign one array to another using the assignment operator
	- that is not legal C
- instead we must use a loop to copy over the elements one at a time.

```c
// this doesn't work
int foo[5] = { 1, 2, 3, 4, 5 };
int bar[5];

bar = foo;

// try this

int foo[5] = { 1, 2, 3, 4, 5 };
int bar[5];

for(int j = 0; j < 5; j++)
{
	bar[j] = foo[j];
}

```

- one thing that's tricky: variable scope, most variables are `passed-by-values`
	- (means we're making a copy)
	- the callee doesn't get its own variables, but its own *copy*
- arrays do not follow this rule
	-  #scoping 
	- arrays are **passed by reference**
	- the callee receives the actual array, ==not a copy of it==
		- what does that mean when the callee manipulates elements of the array?
	- for now, we'll gloss over why arrays have this special property, but we'll return to it soon enough.
	- making copies is not worth it for the function because arrays are so bulk and cumbersome
		- we trust the function to not break anything
		- it gets the full array, not the global copy of it

```c

void set_array(int array[4]);
void set_int(int x);

int main(void)
{
	int a = 10;
	int b[4] = { 0, 1, 2, 3 };
	set_int(a);
	set_array(b);
	printf("%d %d\n", a, b[0]);
}

void set_array(int array[4])
{
	array[0] = 22;
}

void set_int(int x)
{
	x = 22;
}

// should return 10, 22
```

- functions retain a COPY
- arrays provided the full-set
	- this is why `set_int(a)` is ran (presumably given "22", but `a` returns 10
		- the functions copy of `a` or `x`, in this instance, is local to itself `set_int(int x)`
	- `int b[4]` and `set_array(b)` on the other hand;
		- because `set_array(int array[4]` assigns `b` the return value of `array[0] = 22;`
		- `b` = 22

```c
#include <cs50.h>
#include <stdio.h>

void set_array(int array[4]);
void set_int(int x);


int main(void)
{

	int a = 10;
	int b[4] = { 0, 1, 2, 3 };
	set_int(a); // This will not change 'a' in main
	set_array(b); // This will change b[0] to 22
	printf("%d, %d\n", a, b[0]);
}

  

void set_array(int array[4])
{
	array[0] = 22; // This changes b[0] in main to 22
}

  

void set_int(int x)
{
	x = 22; // This changes x locally but not 'a' in main
}
```


#casting

- in C, `char` is essentially a small integer type
- integral data type, stored as a number
- the `%i` or `%d` implicitly converts the `char` to `int` and displays the integer (ASCII value) of the character
	- this is a form of "integer promotion"
- this might only apply to printing
- doing arithemtic or other operations where type needs to be explictly known or controlled
	- you might need to cast the `char` to an `int` or another type explicitly

- strings = arrays of `char` terminated by a null character (`'\0'`)
	- where there are no implicit conversions or promotions for arrays (including strings) are there for single 'chars'
		- there are several conventions and functions int he standard library specifically designed to work with strings (null-terminated `char` arrays)
		- here are a few key points and common operations
1. **string literals:**
	1. when you initialize a `char` array with a string literal, like `char str[] = "Hello";`
		1. C automatically appends the null terminator `'\0'` at the end of the array, marking the end of the string
2. **Printing Strings:**
	1. You can print an entire string using `%s` in `printf`.
		1. it will print characters starting from the beginning of the `char` array until it hits the null terminator.
3. **String Handling Functions**
	1. the C standard library (<string.h>) provides many functions for string manipulation and querying
		1. `strlen` , get the length of a string (non-counting null terminator)
		2. `strcpy` copy one string to another
		3. `strcat` concatenate two strings
		4. `strcmp` compare two strings
	2. these functions expect C strings to be null-terminated
		1. they rely on the null terminator to know where the string ends
4. **Passing Strings to Functions:**
	1. while passing strings to functions, you usually pass a pointer to the first element of the `char` array (e.g. `char* str`) 
	2. inside the function, you can treat this pointer just like an array, thanks to pointer arithmetic and the way C handles arrays and pointers
5. **No bounds checking**
	1. C does not perform automatic bounds checking on arrays
	2. when you're working with strings, it's your responsibility to ensure that you don't access out of bounds and that strings are properly null-terminated
6. **Buffer Overflows:**
	1. Be cautious with functions that write to strings (like `strcpy` and `strcat`)
	2. if the destination array is not large enough to hold the result, it can lead to buffer overflows, a common source of bugs and security vulnerabilities
	3. functions like `strncpy` and `strncat` allow you to specify the maximum number of characters to copy/concatenate and can be safer alternatives

#CS50/arrays 
- C needs to know 3 things for an array
	- name of the array
	- size of the array
	- what kind of data we're storing
- C only stores 1 kind of datatype
	- integers!
- the counting of an array when laid out like this
	-  `int nights[5]`
	- not zero-indexed when written
	- however, when ACCESSED, it is zero-indexed
		- (wtf?)
	- int nights[5] = {7, 8, 6, 7, 8};


Questions
- Can you change the size of an array?
	- you cannot change the size of an array
		- you can allocate more memory later
		- copy from 1 space of memory, into another space
- can an array exist on multiple planes, like a 3d array?
	- you can have arrays within arrays (each array's element is another array)
		- you can iterate on this
		- this results in a 3d kind of structure
- what about negative -1 indexes?
	- programmed in python?
		- `[-1]` for example
	- this is not possible in C
- for `int nights[5]`, could we add only three and later on add the other 2?
	- at the declaration, specify 3 values, then the other 2
	- the final 2 values, or the unspecified values, can be anything.
	- however this only goes for `int nights[5] = {7, 8, 6, 7, 8};`

**Doubling up**
#cs50/arrays #cs50/example
- create an array of integers in where each integer is 2 times the value of the previous integer
- the first element is 1.
- print the array, integer by integer
- e.g. `{1, 2, 4, 8, 16}`

- a `for` loop is good for when we know overall how many times we want to iterate
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int size = 8;
    int sequence[size];

    sequence[0] = 1;
    printf("%i\n", sequence[0]);

    for (int i = 1; i < size; i++)
    {
            sequence[i] = sequence[i - 1] * 2;
            printf("%i\n", sequence[i]);
    }
}
```
- although it is not good practice to invoke "magic numbers"
	- in arrays, it may actually be valid, like in the above example, as it allows us to easily change/specify the array values.
	- (so you don't have to change it everywhere)
	- we can even take user input:
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int size = get_int("Enter a size: ");
    int sequence[size];

    sequence[0] = 1;
    printf("%i\n", sequence[0]);

    for (int i = 1; i < size; i++)
    {
            sequence[i] = sequence[i - 1] * 2;
            printf("%i\n", sequence[i]);
    }
}
```

Strings
#cs50/arrays/strings
- strings work the same way, almost like scrabble?
- strings are nothing more than arrays where elements are characters
- HELLO
	- `phrase[0] = H, [1] = E....`
	- ASCII, we can see how chars map to each integer
		- `A' = 65
	- Consider `H E L L O` again
		- `{72, 69, 76, 76, 79}`

#cs50/example 
Alphabetical
- write a program to check if an array of characters is in alphabetical order or not
- Assume the characters are all upper case

what can we do to loop through the number of characters in a string?
- for loop through the string, since string = array!
- if i'm checking this condition, it is not worth it to run like this
- ![[CleanShot 2024-01-19 at 22.25.01.png]]
- how can we sort this stuff alphabetically?
- ![[CleanShot 2024-01-19 at 22.29.21.png]]
	- you can see that the integers +1 each time...
	- remember that these values are CASE SENSITIVE
- Looking at `B`, the integer is greater than `A`
- If these characters are not in alphabetical order... print `Not in alphabetical order\n`?
#tip
- you can input `return 0;` to state that your program has finished
- looking at the code again:
	- ![[CleanShot 2024-01-19 at 22.35.13.png]]
	- we don't want to be checking values outside of our memory...
	- we can see that `i` encroaches on the boundaries, in this case, `strlen(phrase)`
	- this also surprisingly will not work:
		- ![[CleanShot 2024-01-19 at 22.36.40.png]]
		- this only really looks at the first 2 characters, rather than the full string
		- need to print f at the END!
		- (I really gotta think about what I'm doing before I move on...)
questions
## Command line arguments
#cs50/command-line-arguments
- you may have seen several programs like this before
- if i type in `make alphabetical`
	- i am feeding it some kind of values..
- you can compare this with `check50`
	- you can see, without any parameters, output with information
- can we give, for `mario`, that the user can give some arguments *before* the program even runs?
- in order to have this `$ ./mario 8`
	- `int main (int argc, int argv[])`
	- compared to
	
```c
int main(void)
{
	int height = get_int("H: ");
}
```

```c
int main(int argc, string argv[])
{

}
```

argv
- write a program that prints each command-line argument given to the program
- `argc` refers to the number of arguments that my program received
	- number of inputs, including the name of the program itself
	- `$ ./mario 8` is actually 2 inputs
		- mario, and 8
		- you can see this in action with this
		- ![[CleanShot 2024-01-19 at 22.46.54.png]]
- can be stored in our `argv` as a set of strings
QUESTIONS
- argv is storing a collection of strings, 
- what if we wanted a number?
- allow the user to do `./mario 8` and run the program!
	- we should look in `argv[1]`
- ![[CleanShot 2024-01-19 at 22.49.06.png]]
- not able to store a string inside of this variable was an integer
- have to convert `argv[1]` to an int
- We can do this using the library `stdlib.h`
	- `atoi` will initiate the conversion
- the code runs without errors!
	- ![[CleanShot 2024-01-19 at 22.50.29.png]]
- what if i run like this `$ ./mario`
	- this will result in segmentation fault
	- why would we be looking outside of the bounds of `argv`
	- `argv[1]` assumes we have a bracket of 1
		- therefore to correct, we could try `argv[0]`
	- I also want to tell my user that if there is no input, that they should enter an argument.
	- ![[CleanShot 2024-01-19 at 22.53.47.png]]
- `code argv.c`
`argc` the # of inputs for our program
`argv` the array of inputs to our program at the command line

- what counts as being at the command line
	- `./mario 8 carter`
	- we can also look at `cowsay -f dragon "RAWR"
		- in one single command i ran `cowsay`, then `"RAWR` for what the dragon should be saying

## Scrabble

![[CleanShot 2024-01-19 at 23.21.34.png]]

![[CleanShot 2024-01-19 at 23.21.47.png]]

# More Array Notes
- Compiling
	- encryption is the act of hiding plain text from prying eyes
		- decrypting is the act of taking an encrypted piece of text and returning it to a human-readable form
	- recall that last week you learned about a compiler
		- specialized computer program that converts source code into machine code that can be understood by a computer
		- for example you might have a computer program that looks like this
```c
#include <stdio.h>

int main(void)
{
	printf("hello, world\n");
}
```
- a compiler will take the above code and turn into machine code, binary blocks!
-  *VS Code* the programming environment provided to you, utilizes a compiler called `clang` or *c language*
- if you were to type `make hello`, it runs a command that executes clang to create an output file that you can run as a user
- VS Code has been pre-programmed such that `make` will run numerous command line arguments along with clang for your convenience as a user.
- consider the following code:
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
	string naem = get_string("What's your name? ");
	printf("hello, %s\n", name);
}
```
- you can attempt to enter into the terminal window: `clang -o hello hello.c`
	- you will be met by an error that indicates that clang does not know where to find the `cs50.h` library
- attempting to compile this code, run the following command in the terminal window:
	- `clang -o hello hello.c -lcs50`
	- this will enable the compiler to access the `cs50.h` library
	- running in the terminal window `./hello`, your program will run as intended
	- While the above is offered as an illustration, such that you can understand more deeply the process and concept of compiling code, 
		- using `make` in CS50 is perfectly fine and the expectation
	- Compiling involves major steps (notes above.)
- 1. *Preprocessing* is where the header files in your code are effectively copied and pasted into your file
	- during this step, the code from `cs50.h` is copied into your program
	- similarly, just as your code contains `#include <stdio.h>` code contained within `stdio.h` somewhere on your computer is copied to your program
```c
string get_string(string prompt);
int printf(string format, ...);

int main(void)
{
    string name = get_string("What's your name? ");
    printf("hello, %s\n", name);
}
```
 - 2. *compiling* is where your program is converted into assembly code. this step can be visualized as follows:
	 - ![[CleanShot 2024-01-19 at 23.34.36.png]]
- 3. *assembling* involves the compiler converting your assembly code into machine code; this step can be visualized as follows:
		- ![[CleanShot 2024-01-19 at 23.35.06.png]]
- 4. *linking*: code from your included libraries are converted also into machine code and combined with your code
	- the final executable file is then outputted
		- ![[CleanShot 2024-01-19 at 23.35.56.png]]
## Debugging
- everyone will make mistakes while coding
- basically
	- rubber duck
	- break points
	- debug50, win the game.

## Arrays
- in week 0, we talked about *data types* such as `bool`, `int`, `char`, `string`, etc.
- each data type requires a certain amount of system resources:
	- `bool` 1 byte
	- `int` 4 bytes
	- `long` 8 bytes
	- `float` 4 bytes
	- `double` 8 bytes
	- `char` 1 byte
	- `string` ? bytes
- inside of your computer, you have a finite amount of memory available
- Physically on the memory of your PC, you can imagine how specific types of data are stored on your computer
	- you might imagine that a `char` only requires 1 byte of memory may look as follows:
		- ![[CleanShot 2024-01-19 at 23.38.20.png]]
	- similarly, an `int`, which requires 4 bytes might look as follows:
		- ![[CleanShot 2024-01-19 at 23.38.34.png]]
	- we can create a program that explores these concepts.
		- inside your terminal, type `code scores.c` and write code as follows:
```c
#include <stdio.h>

int main(void)
{
	// Scores
	int score1 = 72;
	int score2 = 73;
	int score3 = 33;

	// Print average
	printf("Average: %f\n", (score1 + score2 + score3) / 3.0);
}
```
- notice that the number on the right is a floating point value of `3.0` such that the calculation is rendered as a floating point value in the end
- running `make scores`, the program runs
- You can imagine how these variables are stored in memory:
	- ![[CleanShot 2024-01-19 at 23.40.31.png]]
- *Arrays* are a way of storing data back-to-back in memory such that this data is easilya ccesible
- `int scores[3]` is a way of telling the compiler to provide you 3 back-to-back places in memory of size `int` to store 3 `scores`
	- considering our program, you can revise your code as follows:
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
	// Get Scores
	int scores[3];
	scores[0] = get_int("Score: ");
	scores[1] = get_int("Score: ");
	scores[2] = get_int("Score: ");

	// Print average
	printf("Average: %f\n", (scores[0] + scores[1] + scores[2] / 3.0);
}
```
- notice that `score[0]` examines the value at this location of memory by `indexing into` the array called `scores` at location `0` to see what value is stored there